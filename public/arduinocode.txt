#include <WiFi.h>
#include <Firebase_ESP_Client.h>

// Firebase Addons
#include "addons/TokenHelper.h"
#include "addons/RTDBHelper.h"

// WiFi-Zugangsdaten
// HINWEIS: Es wird empfohlen, diese in einer separaten "config.h"-Datei zu speichern,
// die von der Versionskontrolle (git) ignoriert wird, um zu vermeiden,
// dass sensible Daten veröffentlicht werden.
#define WIFI_SSID "BioThrust"
#define WIFI_PASSWORD "WORKBOX-declare-mescal-lion"

// Firebase-Zugangsdaten
#define API_KEY "AIzaSyCm5iVRj1hOG9NlBtLydsOW-H51d0IdoQs"
#define DATABASE_URL "https://studio-946072313-2310e-default-rtdb.europe-west1.firebasedatabase.app/"
#define USER_EMAIL "esp32@biothrust.app"
#define USER_PASSWORD "esp32esp32"

// Pin-Definitionen
const int analogPin = A0;   // A0 ist normal (oft GPIO 36)
const int valve1Pin = 18; // GPIO 18
const int valve2Pin = 19; // GPIO 19

// *** KORREKTUR ***
// D2 und D3 sind nicht standardmäßig. Bitte passe Sie an dein Board an.
// Beispiel: D2 ist oft GPIO 2, D3 ist auf manchen Boards GPIO 0 (Boot-Pin, riskant!)
// Ich verwende hier GPIO 2 und GPIO 4 als sichere Beispiele.
const int valve1LedPin = 2; // War D2. Bitte an dein Board anpassen!
const int valve2LedPin = 4; // War D3. Bitte an dein Board anpassen!


// Firebase-Objekte
FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;

// Timing-Variablen
unsigned long lastSensorTime = 0;
unsigned long lastStatusTime = 0;
unsigned long lastCommandCheck = 0;

// System-Status
bool valve1 = false;
bool valve2 = false;
bool recordingActive = false;
String currentSessionId = "";
unsigned long sessionStartTime = 0;

// =================================================================
// *** NEU: Funktions-Prototypen (Forward Declarations) ***
// Dies hilft dem Compiler/Linker, Funktionen zu finden,
// die weiter unten im Code definiert sind.
// =================================================================
void printStatus();
String getISOTimestamp();
// Die 'tokenStatusCallback' Deklaration wird aus TokenHelper.h geladen

// =================================================================
//                     SETUP
// =================================================================
void setup() {
  // Serial für Debugging (bleibt IMMER aktiv!)
  Serial.begin(115200);
  delay(500);
  Serial.println("\n=== ESP32 Studio Sensor System ===");
  Serial.println("Version: 1.2 (Whitespace-Fixed)");
  
  // Pin-Konfiguration
  pinMode(analogPin, INPUT);
  pinMode(valve1Pin, OUTPUT);
  pinMode(valve2Pin, OUTPUT);
  pinMode(valve1LedPin, OUTPUT);
  pinMode(valve2LedPin, OUTPUT);
  
  digitalWrite(valve1Pin, LOW);
  digitalWrite(valve2Pin, LOW);
  digitalWrite(valve1LedPin, LOW);
  digitalWrite(valve2LedPin, LOW);
  
  Serial.println("[GPIO] Pins initialisiert");
  
  // WiFi-Verbindung
  Serial.printf("[WiFi] Verbinde mit %s...\n", WIFI_SSID);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  
  int wifiTimeout = 0;
  while (WiFi.status() != WL_CONNECTED && wifiTimeout < 30) {
    delay(500);
    Serial.print(".");
    wifiTimeout++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n[WiFi] ✓ Verbunden!");
    Serial.printf("[WiFi] IP: %s\n", WiFi.localIP().toString().c_str());
    Serial.printf("[WiFi] Signal: %d dBm\n", WiFi.RSSI());
  } else {
    Serial.println("\n[WiFi] ✗ FEHLER: Verbindung fehlgeschlagen!");
    Serial.println("[System] Arbeite nur im Serial-Debug-Modus");
    Serial.println("[System] READY (Serial-only mode)");
    return; // Im Fehlerfall hier stoppen (kein Firebase)
  }
  
  // Firebase initialisieren
  Serial.println("[Firebase] Initialisiere...");
  config.api_key = API_KEY;
  config.database_url = DATABASE_URL;
  auth.user.email = USER_EMAIL;
  auth.user.password = USER_PASSWORD;
  
  // Token-Status-Callback
  // Diese Zuweisung ist KORREKT. Die Funktion selbst
  // wird von "addons/TokenHelper.h" bereitgestellt.
  config.token_status_callback = tokenStatusCallback;
  
  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);
  
  // Warten bis Firebase bereit ist (optional, aber gut für den Start)
  // Serial.println("[Firebase] Warte auf Token...");
  // while (!Firebase.ready()) {
  //   delay(500);
  //   Serial.print(".");
  // }
  // Serial.println("\n[Firebase] ✓ Token erhalten!");
  
  Serial.println("[Firebase] ✓ Initialisierung gestartet.");
  Serial.printf("[Firebase] Database: %s\n", DATABASE_URL);
  Serial.println("[System] ✓ READY");
  Serial.println("=====================================");
  Serial.println("Serial Commands:");
  Serial.println("  VALVE1:ON / VALVE1:OFF");
  Serial.println("  VALVE2:ON / VALVE2:OFF");
  Serial.println("  START / STOP (Recording)");
  Serial.println("  STATUS (System-Info)");
  Serial.println("=====================================\n");
}

// =================================================================
//                     LOOP
// =================================================================
void loop() {

  // Sensor immer auslesen (für Serial Debug)
  if (millis() - lastSensorTime > 500) {
    lastSensorTime = millis();
    int sensorValue = analogRead(analogPin);
    unsigned long timestamp = millis();
    
    // Immer auf Serial ausgeben (Debug)
    Serial.printf("[Sensor] %d | %lu ms", sensorValue, timestamp);
    if (recordingActive) {
      Serial.print(" [REC]");
    }
    Serial.println();
    
    // Firebase nur wenn verbunden
    if (Firebase.ready()) {
      // LIVE-Wert (wird überschrieben, keine Historie!)
      if (Firebase.RTDB.setInt(&fbdo, "/live/sensor", sensorValue)) {
        // Erfolg - optional debug message
      } else {
        Serial.printf("[Firebase] Fehler: %s\n", fbdo.errorReason().c_str());
      }
      
      Firebase.RTDB.setInt(&fbdo, "/live/timestamp", timestamp);
      
      // Wenn Recording aktiv: In Session speichern
      if (recordingActive && currentSessionId != "") {
        // Pfad mit String-Objekt erstellen
        String path = "/sessions/" + currentSessionId + "/data/" + String(timestamp);
        
        // JSON-Objekt für bessere Performance
        FirebaseJson json;
        json.set("value", sensorValue);
        json.set("time", timestamp);
        json.set("relativeTime", timestamp - sessionStartTime);
        
        // Senden
        if (Firebase.RTDB.setJSON(&fbdo, path.c_str(), &json)) {
          // Erfolg
        } else {
          Serial.printf("[Recording] Fehler: %s\n", fbdo.errorReason().c_str());
        }
      }
    }
  }
  
  // Ventilstatus alle 1000ms senden
  if (millis() - lastStatusTime > 1000) {
    lastStatusTime = millis();
    
    if (Firebase.ready()) {
      Firebase.RTDB.setBool(&fbdo, "/live/valve1", valve1);
      Firebase.RTDB.setBool(&fbdo, "/live/valve2", valve2);
      Firebase.RTDB.setBool(&fbdo, "/live/recording", recordingActive);
    }
  }
  
  // Commands von Firebase lesen (alle 200ms)
  if (Firebase.ready() && millis() - lastCommandCheck > 200) {
    lastCommandCheck = millis();
    
    // Valve 1 Command
    if (Firebase.RTDB.getBool(&fbdo, "/commands/valve1")) {
      bool newState = fbdo.boolData();
      if (newState != valve1) {
        valve1 = newState;
        digitalWrite(valve1Pin, valve1 ? HIGH : LOW);
        digitalWrite(valve1LedPin, valve1 ? HIGH : LOW);
        Serial.printf("[Command] Valve1 -> %s\n", valve1 ? "ON" : "OFF");
      }
    }
    
    // Valve 2 Command
    if (Firebase.RTDB.getBool(&fbdo, "/commands/valve2")) {
      bool newState = fbdo.boolData();
      if (newState != valve2) {
        valve2 = newState;
        digitalWrite(valve2Pin, valve2 ? HIGH : LOW);
        digitalWrite(valve2LedPin, valve2 ? HIGH : LOW);
        Serial.printf("[Command] Valve2 -> %s\n", valve2 ? "ON" : "OFF");
      }
    }
    
    // Recording Command
    if (Firebase.RTDB.getBool(&fbdo, "/commands/recording")) {
      bool shouldRecord = fbdo.boolData();
      
      if (shouldRecord && !recordingActive) {
        // START RECORDING
        recordingActive = true;
        currentSessionId = String(millis()); // Eindeutige ID
        sessionStartTime = millis();
        
        // Session-Metadaten speichern
        String metaPath = "/sessions/" + currentSessionId + "/meta";
        FirebaseJson meta;
        meta.set("id", currentSessionId);
        meta.set("startTime", sessionStartTime);
        meta.set("startTimeISO", getISOTimestamp()); // Verwendet deine Funktion
        meta.set("status", "recording");
        
        Firebase.RTDB.setJSON(&fbdo, metaPath.c_str(), &meta);
        
        Serial.println("=====================================");
        Serial.printf("[Recording] ▶ GESTARTET\n");
        Serial.printf("[Recording] Session: %s\n", currentSessionId.c_str());
        Serial.println("=====================================");
        
      } else if (!shouldRecord && recordingActive) {
        // STOP RECORDING
        String metaPath = "/sessions/" + currentSessionId + "/meta";
        FirebaseJson meta;
        meta.set("endTime", millis());
        meta.set("endTimeISO", getISOTimestamp()); // Verwendet deine Funktion
        meta.set("duration", millis() - sessionStartTime);
        meta.set("status", "completed");
        
        // Verwende updateNode, um nur die End-Daten hinzuzufügen,
        // ohne die Start-Daten zu überschreiben.
        Firebase.RTDB.updateNode(&fbdo, metaPath.c_str(), &meta);
        
        Serial.println("=====================================");
        Serial.printf("[Recording] ■ GESTOPPT\n");
        Serial.printf("[Recording] Session: %s\n", currentSessionId.c_str());
        Serial.printf("[Recording] Dauer: %lu ms\n", millis() - sessionStartTime);
        Serial.println("=====================================");
        
        recordingActive = false;
        currentSessionId = "";
        sessionStartTime = 0;
      }
    }
  }
  
  // Serial Commands (für Debug)
  if (Serial.available()) {
    String cmd = Serial.readStringUntil('\n');
    cmd.trim(); // Entfernt unsichtbare Zeichen
    
    Serial.printf("[Serial] Command: %s\n", cmd.c_str());
    
    if (cmd == "VALVE1:ON") {
      valve1 = true;
      digitalWrite(valve1Pin, HIGH);
      digitalWrite(valve1LedPin, HIGH);
      if (Firebase.ready()) Firebase.RTDB.setBool(&fbdo, "/commands/valve1", true);
      Serial.println("[Serial] ✓ Valve1 ON");
    }
    else if (cmd == "VALVE1:OFF") {
      valve1 = false;
      digitalWrite(valve1Pin, LOW);
      digitalWrite(valve1LedPin, LOW);
      if (Firebase.ready()) Firebase.RTDB.setBool(&fbdo, "/commands/valve1", false);
      Serial.println("[Serial] ✓ Valve1 OFF");
    }
    else if (cmd == "VALVE2:ON") {
      valve2 = true;
      digitalWrite(valve2Pin, HIGH);
      digitalWrite(valve2LedPin, HIGH);
      if (Firebase.ready()) Firebase.RTDB.setBool(&fbdo, "/commands/valve2", true);
      Serial.println("[Serial] ✓ Valve2 ON");
    }
    else if (cmd == "VALVE2:OFF") {
      valve2 = false;
      digitalWrite(valve2Pin, LOW);
      digitalWrite(valve2LedPin, LOW);
      if (Firebase.ready()) Firebase.RTDB.setBool(&fbdo, "/commands/valve2", false);
      Serial.println("[Serial] ✓ Valve2 OFF");
    }
    else if (cmd == "START") {
      if (Firebase.ready()) {
        Firebase.RTDB.setBool(&fbdo, "/commands/recording", true);
        Serial.println("[Serial] ✓ Recording START command sent");
      }
    }
    else if (cmd == "STOP") {
      if (Firebase.ready()) {
        Firebase.RTDB.setBool(&fbdo, "/commands/recording", false);
        Serial.println("[Serial] ✓ Recording STOP command sent");
      }
    }
    else if (cmd == "STATUS") {
      printStatus();
    }
    else {
      Serial.println("[Serial] ✗ Unbekannter Command");
    }
  }
} // Ende von loop()

// =================================================================
//                 HELPER-FUNKTIONEN
// =================================================================

// *** HINWEIS: Die Definition für 'tokenStatusCallback' wurde ENTFERNT, ***
// da sie von addons/TokenHelper.h bereitgestellt wird.


// Hilfsfunktion: Status ausgeben
void printStatus() {
  Serial.println("\n=====================================");
  Serial.println("        SYSTEM STATUS");
  Serial.println("=====================================");
  Serial.printf("WiFi:      %s\n", WiFi.status() == WL_CONNECTED ? "✓ Verbunden" : "✗ Getrennt");
  if (WiFi.status() == WL_CONNECTED) {
    Serial.printf("IP:        %s\n", WiFi.localIP().toString().c_str());
    Serial.printf("Signal:    %d dBm\n", WiFi.RSSI());
  }
  Serial.printf("Firebase:  %s\n", Firebase.ready() ? "✓ Bereit" : "✗ Nicht bereit");
  Serial.printf("Recording: %s\n", recordingActive ? "▶ AKTIV" : "■ INAKTIV");
  if (recordingActive) {
    Serial.printf("Session:   %s\n", currentSessionId.c_str());
    Serial.printf("Dauer:     %lu ms\n", millis() - sessionStartTime);
  }
  Serial.printf("Valve1:    %s\n", valve1 ? "ON" : "OFF");
  Serial.printf("Valve2:    %s\n", valve2 ? "ON" : "OFF");
  Serial.printf("Uptime:    %lu ms\n", millis());
  Serial.println("=====================================\n");
}

// Hilfsfunktion: ISO Timestamp
// HINWEIS: Diese Funktion gibt aktuell nur millis() als String zurück,
// keinen echten ISO-8601-Timestamp.
// Die Logik wurde NICHT geändert.
String getISOTimestamp() {
  unsigned long ms = millis();
  return String(ms);
}
